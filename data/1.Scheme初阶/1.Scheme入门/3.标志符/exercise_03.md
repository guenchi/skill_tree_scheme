# 标志符

Scheme对标识符的宽容度远大于其他语言，你可以在标识符里使用大多数符号，可以重写所有的系统预留关键字，但仍有一些符号严格禁止使用在标志符里。

在Scheme里它们大多数是预留的读取器宏。

> 读取器宏是一种在编译前对代码进行替换的工具，你可以将它看作高级版的C语言宏。在Scheme的近亲语言，Common Lisp里你可以自由的编写读取器宏。在Scheme的世界里读取器宏被视作邪恶而混乱的，只预留了少量程序语言标准层面的读取器宏来简化程序编写。

```
#                    
```

编译器预留符号, 它用来表示字符，比如`#\a #\b #\c`。用来表示进制数，比如`#b100 #x7C0`，用来表示向量，比如`#(1 2 3)`。用来表示编译器行为钩子,比如`(#3%display "Hello,World!")`在ChezScheme中表示强制用第三级优化火力全开的display hello world。

```
'     单引号
```
读取器宏，`'object`将在编译前被替换成`(quote object)`。它也用来表示列表，如`'(a b c)`. 

> 在Scheme中，quote有重要的作用，它代表标志符的符号的一面。而不被quote住的标志符代表它作为程序的一面。LISP与其他程序语言最大的区别即是代码即是数据，数据即是代码。在这种情况下我们必须明确一个标志符在当下是否被自动进行求值。即它对编译器展现它名字的一面，还是它程序的一面。这个区别便由quote来表示。 

```
`    往右斜的单引号
```
读取器宏，`` `object ``将在编译前被替换成`(quasiquote object)`。

```
,     逗号
```
读取器宏，`,object`将在编译前被替换成`(unquote object)`。

```
@  
```
读取器宏，`,@object`将在编译前被替换成`(unquote-splicing object)`。

在Scheme规定中`@`只是不能出现在标致符的开头。但实际使用中，含`@`的标志符会导致太多问题。比如，在标志符尾部的`@`有可能影响读取器对右括号的读取。所以这里尽量建议不要在标志符中使用`@`。


```
.
```
`.`在scheme程序中起到表示"对"的作用。比如(a . b)。它不能使用在标识符的开头。

```
+
-
```
`+`和`-`因为需要表示数学格式，所以不能出现在标志符的开头。

*特例*

```
->
```
`->`组合在标志符开头是合法的。


> 可以使用在标识符里的字符有：`? ! . + - * / < = > : $ % ^ & _ ~`。